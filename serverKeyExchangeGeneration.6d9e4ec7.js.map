{"mappings":"A,C,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,C,E,iB,C,Q,C,Q,S,C,C,C,ECAA,EAAA,OAAA,CAAiB,KAAK,KAAA,CAAM,yqC","sources":["<anon>","src/TLS12/serverKeyExchangeGeneration.json"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar parcelRequire = $parcel$global[\"parcelRequire7f38\"];\nparcelRequire.register(\"1Jw7E\", function(module, exports) {\nmodule.exports = JSON.parse('[\"服务器端需要生成一个用于密钥交换的自己的“私钥/公钥”对。密钥交换(Key exchange)是一种技术，双方可以在同一数字上达成一致，而窃听者却无法知道这个数字是什么。\",{\"Tag\":\"p\",\"children\":[\"学习 TLS 并不需要深入了解，但你可以从\",{\"Tag\":\"a\",\"props\":{\"href\":\"https://x25519.xargs.org/\"},\"content\":\"X25519 密钥交换算法\"},\"获取涉及到的密钥交换算法的具体解释。\"]},[\"**私钥**是 0 到 \",{\"Tag\":\"Math\",\"content\":\"2^256-1\"},\" 之间的一个随机整数(32bytes, 256bits)\",\"。为方便后续解释，假设我们生成的私钥是：\"],{\"Tag\":\"pre\",\"props\":{\"className\":\"ind2\"},\"children\":[{\"Tag\":\"code\",\"props\":{\"className\":\"longboi\"},\"content\":\"909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf\"}]},\"**公钥**由上面提到的 X25519 密钥交换算法生成。例子中计算出的公钥应如下所示：\",{\"Tag\":\"pre\",\"props\":{\"className\":\"ind2\"},\"children\":[{\"Tag\":\"code\",\"props\":{\"className\":\"longboi\"},\"content\":\"9fd7ad6dcff4298dd3f96d5b1b2af910a0535b1488d7f8fabb349a982880b615\"}]},\"公钥的计算也可以在命令行中运行以下命令得到：\",{\"Tag\":\"CodeSample\",\"props\":{\"code\":\"### requires openssl 1.1.0 or higher\\\\n$ openssl pkey -noout -text < server-ephemeral-private.key\\\\n\\\\nX25519 Private-Key:\\\\npriv:\\\\n    90:91:92:93:94:95:96:97:98:99:9a:9b:9c:9d:9e:\\\\n    9f:a0:a1:a2:a3:a4:a5:a6:a7:a8:a9:aa:ab:ac:ad:\\\\n    ae:af\\\\npub:\\\\n    9f:d7:ad:6d:cf:f4:29:8d:d3:f9:6d:5b:1b:2a:f9:\\\\n    10:a0:53:5b:14:88:d7:f8:fa:bb:34:9a:98:28:80:\\\\n    b6:15\"}}]');\n\n});\n\n\n//# sourceMappingURL=serverKeyExchangeGeneration.6d9e4ec7.js.map\n","[\n  \"服务器端需要生成一个用于密钥交换的自己的“私钥/公钥”对。密钥交换(Key exchange)是一种技术，双方可以在同一数字上达成一致，而窃听者却无法知道这个数字是什么。\",\n  {\n    \"Tag\": \"p\",\n    \"children\": [\n      \"学习 TLS 并不需要深入了解，但你可以从\",\n      {\n        \"Tag\": \"a\",\n        \"props\": { \"href\": \"https://x25519.xargs.org/\" },\n        \"content\": \"X25519 密钥交换算法\"\n      },\n      \"获取涉及到的密钥交换算法的具体解释。\"\n    ]\n  },\n  [\n    \"**私钥**是 0 到 \",\n    {\n      \"Tag\": \"Math\",\n      \"content\": \"2^256-1\"\n    },\n    \" 之间的一个随机整数(32bytes, 256bits)\",\n    \"。为方便后续解释，假设我们生成的私钥是：\"\n  ],\n  {\n    \"Tag\": \"pre\",\n    \"props\": {\n      \"className\": \"ind2\"\n    },\n    \"children\": [\n      {\n        \"Tag\": \"code\",\n        \"props\": { \"className\": \"longboi\" },\n        \"content\": \"909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf\"\n      }\n    ]\n  },\n  \"**公钥**由上面提到的 X25519 密钥交换算法生成。例子中计算出的公钥应如下所示：\",\n  {\n    \"Tag\": \"pre\",\n    \"props\": {\n      \"className\": \"ind2\"\n    },\n    \"children\": [\n      {\n        \"Tag\": \"code\",\n        \"props\": { \"className\": \"longboi\" },\n        \"content\": \"9fd7ad6dcff4298dd3f96d5b1b2af910a0535b1488d7f8fabb349a982880b615\"\n      }\n    ]\n  },\n  \"公钥的计算也可以在命令行中运行以下命令得到：\",\n  {\n    \"Tag\": \"CodeSample\",\n    \"props\": {\n      \"code\": \"### requires openssl 1.1.0 or higher\\n$ openssl pkey -noout -text < server-ephemeral-private.key\\n\\nX25519 Private-Key:\\npriv:\\n    90:91:92:93:94:95:96:97:98:99:9a:9b:9c:9d:9e:\\n    9f:a0:a1:a2:a3:a4:a5:a6:a7:a8:a9:aa:ab:ac:ad:\\n    ae:af\\npub:\\n    9f:d7:ad:6d:cf:f4:29:8d:d3:f9:6d:5b:1b:2a:f9:\\n    10:a0:53:5b:14:88:d7:f8:fa:bb:34:9a:98:28:80:\\n    b6:15\"\n    }\n  }\n]\n"],"names":["globalThis","self","window","global","register","module","exports","JSON","parse"],"version":3,"file":"serverKeyExchangeGeneration.6d9e4ec7.js.map"}