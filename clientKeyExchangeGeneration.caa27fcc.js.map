{"mappings":"A,C,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,C,E,iB,C,Q,C,Q,S,C,C,C,ECAA,EAAA,OAAA,CAAiB,KAAK,KAAA,CAAM,utC","sources":["<anon>","src/TLS13/clientKeyExchangeGeneration.json"],"sourcesContent":["var $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar parcelRequire = $parcel$global[\"parcelRequire7f38\"];\nparcelRequire.register(\"h8urt\", function(module, exports) {\nmodule.exports = JSON.parse('[\"连接开始时，客户端生成一个用于密钥交换的“私钥/公钥”对。密钥交换(Key exchange)是一种技术，双方可以在同一数字上达成一致，而窃听者却无法知道这个数字是什么。\",{\"Tag\":\"p\",\"children\":[\"学习 TLS 并不需要深入了解，但你可以从\",{\"Tag\":\"a\",\"props\":{\"href\":\"https://cangsdarm.github.io/illustrate/x25519\"},\"content\":\"X25519 密钥交换算法\"},\"获取涉及到的密钥交换算法的具体解释。\"]},[\"**私钥**是 0 到 \",{\"Tag\":\"Math\",\"content\":\"2^256-1\"},\" 之间的一个随机整数(32bytes, 256bits)\",\"。为方便后续解释，假设我们生成的私钥是：\"],{\"Tag\":\"pre\",\"props\":{\"className\":\"ind2\"},\"children\":[{\"Tag\":\"code\",\"props\":{\"className\":\"longboi\"},\"content\":\"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"}]},\"**公钥**由上面提到的 X25519 密钥交换算法生成。例子中计算出的公钥应如下所示：\",{\"Tag\":\"pre\",\"props\":{\"className\":\"ind2\"},\"children\":[{\"Tag\":\"code\",\"props\":{\"className\":\"longboi\"},\"content\":\"358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254\"}]},\"公钥的计算也可以在命令行中运行以下命令得到：\",{\"Tag\":\"CodeSample\",\"props\":{\"code\":\"### requires openssl 1.1.0 or higher\\\\n$ openssl pkey -noout -text < client-ephemeral-private.key\\\\n\\\\nX25519 Private-Key:\\\\npriv:\\\\n    20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:\\\\n    2f:30:31:32:33:34:35:36:37:38:39:3a:3b:3c:3d:\\\\n    3e:3f\\\\npub:\\\\n    35:80:72:d6:36:58:80:d1:ae:ea:32:9a:df:91:21:\\\\n    38:38:51:ed:21:a2:8e:3b:75:e9:65:d0:d2:cd:16:\\\\n    62:54\"}},\"此时，网络连接仍在准备中，没有任何数据被传输。\"]');\n\n});\n\n\n//# sourceMappingURL=clientKeyExchangeGeneration.caa27fcc.js.map\n","[\n  \"连接开始时，客户端生成一个用于密钥交换的“私钥/公钥”对。密钥交换(Key exchange)是一种技术，双方可以在同一数字上达成一致，而窃听者却无法知道这个数字是什么。\",\n  {\n    \"Tag\": \"p\",\n    \"children\": [\n      \"学习 TLS 并不需要深入了解，但你可以从\",\n      {\n        \"Tag\": \"a\",\n        \"props\": { \"href\": \"https://cangsdarm.github.io/illustrate/x25519\" },\n        \"content\": \"X25519 密钥交换算法\"\n      },\n      \"获取涉及到的密钥交换算法的具体解释。\"\n    ]\n  },\n  [\n    \"**私钥**是 0 到 \",\n    {\n      \"Tag\": \"Math\",\n      \"content\": \"2^256-1\"\n    },\n    \" 之间的一个随机整数(32bytes, 256bits)\",\n    \"。为方便后续解释，假设我们生成的私钥是：\"\n  ],\n  {\n    \"Tag\": \"pre\",\n    \"props\": {\n      \"className\": \"ind2\"\n    },\n    \"children\": [\n      {\n        \"Tag\": \"code\",\n        \"props\": { \"className\": \"longboi\" },\n        \"content\": \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n      }\n    ]\n  },\n  \"**公钥**由上面提到的 X25519 密钥交换算法生成。例子中计算出的公钥应如下所示：\",\n  {\n    \"Tag\": \"pre\",\n    \"props\": {\n      \"className\": \"ind2\"\n    },\n    \"children\": [\n      {\n        \"Tag\": \"code\",\n        \"props\": { \"className\": \"longboi\" },\n        \"content\": \"358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254\"\n      }\n    ]\n  },\n  \"公钥的计算也可以在命令行中运行以下命令得到：\",\n  {\n    \"Tag\": \"CodeSample\",\n    \"props\": {\n      \"code\": \"### requires openssl 1.1.0 or higher\\n$ openssl pkey -noout -text < client-ephemeral-private.key\\n\\nX25519 Private-Key:\\npriv:\\n    20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:\\n    2f:30:31:32:33:34:35:36:37:38:39:3a:3b:3c:3d:\\n    3e:3f\\npub:\\n    35:80:72:d6:36:58:80:d1:ae:ea:32:9a:df:91:21:\\n    38:38:51:ed:21:a2:8e:3b:75:e9:65:d0:d2:cd:16:\\n    62:54\"\n    }\n  },\n  \"此时，网络连接仍在准备中，没有任何数据被传输。\"\n]\n"],"names":["globalThis","self","window","global","register","module","exports","JSON","parse"],"version":3,"file":"clientKeyExchangeGeneration.caa27fcc.js.map"}